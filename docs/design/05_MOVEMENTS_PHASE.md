# Phase 5: Movements Migration to PostgreSQL

> **Status:** üìã PLANNED
>
> This phase migrates movements (gastos) from n8n ‚Üí Google Sheets to PostgreSQL + n8n dual-write,
> following the same pattern successfully implemented for income tracking in Phase 4.

**Architecture:**

- Authentication: PostgreSQL + Go backend ‚úÖ
- Households & Payment Methods: PostgreSQL + Go backend ‚úÖ
- Accounts & Income: PostgreSQL + Go backend ‚úÖ
- **NEW:** Movements storage: PostgreSQL + Go backend (dual-write to n8n/Google Sheets)

**Relationship to other phases:**

- See `01_AUTH_PHASE.md` for authentication implementation
- See `02_HOUSEHOLD_PHASE.md` for household/members/contacts management
- See `03_PAYMENT_METHODS_PHASE.md` for payment methods
- See `04_ACCOUNTS_AND_INCOME_PHASE.md` for accounts and income (dual-write pattern)
- See `00_N8N_PHASE.md` for current movement registration
- See `FUTURE_VISION.md` for long-term product direction

---

## üéØ Goals

### Primary Goals

1. **Create PostgreSQL schema for movements**
   - Main `movements` table for all movement types (HOUSEHOLD, SPLIT, DEBT_PAYMENT)
   - `movement_participants` table for SPLIT movements
   - Proper foreign keys to users, contacts, payment methods, accounts

2. **Implement dual-write pattern** (like income)
   - Save to PostgreSQL first
   - Forward to n8n webhook for Google Sheets sync
   - Handle n8n failures gracefully

3. **Update frontend to use new API**
   - Send structured data with IDs (not names)
   - Call Go backend instead of n8n directly
   - Maintain same UX

4. **Data migration strategy**
   - Plan for migrating historical data from Google Sheets
   - Validate data integrity

### Why This Change?

**Current limitations:**
- All movement data locked in Google Sheets (not queryable from app)
- No referential integrity (names as strings)
- Can't build analytics/reports easily
- Dependent on n8n availability for ALL operations

**Solution:**
- PostgreSQL becomes source of truth
- Google Sheets becomes read-only backup/export
- Enable future features: expense tracking, budgets, analytics
- Follows proven pattern from income implementation

---

## üìä Database Schema

### Current Google Sheets Structure

**Gastos table:**
- ID_Gasto (UUID - generated by backend)
- Fecha (DATE)
- Categor√≠a (TEXT)
- Valor (DECIMAL)
- Tipo de gasto (FAMILIAR | COMPARTIDO | PAGO_DEUDA) ‚Üê Will receive HOUSEHOLD, SPLIT, DEBT_PAYMENT from backend
- Pagador (TEXT name)
- Contraparte (TEXT name - only for DEBT_PAYMENT)
- Medio de pago (TEXT name)
- Descripci√≥n (TEXT)
- Moneda (TEXT - always "COP")

**GastoParticipantes table:** (for SPLIT movements only)
- ID_Gasto (UUID - FK to Gastos)
- Persona (TEXT name)
- Porcentaje (DECIMAL)

**Note:** Mes (YYYY-MM) and Semana (YYYY-W##) are computed by n8n/Google Sheets and don't need to be stored in PostgreSQL (can be derived from fecha).

### New PostgreSQL Schema

#### Migration 016: Create movements table

```sql
-- Create movement_type enum
CREATE TYPE movement_type AS ENUM ('HOUSEHOLD', 'SPLIT', 'DEBT_PAYMENT');

-- Create movements table
CREATE TABLE movements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    household_id UUID NOT NULL REFERENCES households(id) ON DELETE CASCADE,
    
    -- Movement type and metadata
    type movement_type NOT NULL,
    description TEXT NOT NULL,
    amount DECIMAL(15, 2) NOT NULL CHECK (amount > 0),
    category VARCHAR(100), -- Required for HOUSEHOLD and DEBT_PAYMENT, nullable for SPLIT
    movement_date DATE NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'COP',
    
    -- Payer (user or contact - exactly one required)
    payer_user_id UUID REFERENCES users(id) ON DELETE RESTRICT,
    payer_contact_id UUID REFERENCES contacts(id) ON DELETE RESTRICT,
    CHECK (
        (payer_user_id IS NOT NULL AND payer_contact_id IS NULL) OR 
        (payer_user_id IS NULL AND payer_contact_id IS NOT NULL)
    ),
    
    -- Counterparty (only for DEBT_PAYMENT - user or contact)
    counterparty_user_id UUID REFERENCES users(id) ON DELETE RESTRICT,
    counterparty_contact_id UUID REFERENCES contacts(id) ON DELETE RESTRICT,
    CHECK (
        -- For DEBT_PAYMENT, exactly one counterparty required
        -- For other types, both must be NULL
        (type = 'DEBT_PAYMENT' AND (
            (counterparty_user_id IS NOT NULL AND counterparty_contact_id IS NULL) OR 
            (counterparty_user_id IS NULL AND counterparty_contact_id IS NOT NULL)
        )) OR
        (type != 'DEBT_PAYMENT' AND counterparty_user_id IS NULL AND counterparty_contact_id IS NULL)
    ),
    
    -- Payment method (required for HOUSEHOLD, conditional for SPLIT/DEBT_PAYMENT)
    payment_method_id UUID REFERENCES payment_methods(id) ON DELETE RESTRICT,
    
    -- Metadata
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_movements_household ON movements(household_id);
CREATE INDEX idx_movements_type ON movements(type);
CREATE INDEX idx_movements_date ON movements(movement_date);
CREATE INDEX idx_movements_household_date ON movements(household_id, movement_date);
CREATE INDEX idx_movements_payer_user ON movements(payer_user_id) WHERE payer_user_id IS NOT NULL;
CREATE INDEX idx_movements_payer_contact ON movements(payer_contact_id) WHERE payer_contact_id IS NOT NULL;
CREATE INDEX idx_movements_counterparty_user ON movements(counterparty_user_id) WHERE counterparty_user_id IS NOT NULL;
CREATE INDEX idx_movements_counterparty_contact ON movements(counterparty_contact_id) WHERE counterparty_contact_id IS NOT NULL;
CREATE INDEX idx_movements_payment_method ON movements(payment_method_id) WHERE payment_method_id IS NOT NULL;
```

#### Migration 017: Create movement_participants table

```sql
-- Create movement_participants table (for SPLIT movements)
CREATE TABLE movement_participants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    movement_id UUID NOT NULL REFERENCES movements(id) ON DELETE CASCADE,
    
    -- Participant (user or contact - exactly one required)
    participant_user_id UUID REFERENCES users(id) ON DELETE RESTRICT,
    participant_contact_id UUID REFERENCES contacts(id) ON DELETE RESTRICT,
    CHECK (
        (participant_user_id IS NOT NULL AND participant_contact_id IS NULL) OR 
        (participant_user_id IS NULL AND participant_contact_id IS NOT NULL)
    ),
    
    -- Percentage (0.0 to 1.0, e.g., 0.25 = 25%)
    percentage DECIMAL(5, 4) NOT NULL CHECK (percentage > 0 AND percentage <= 1),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Prevent duplicate participants in same movement
    UNIQUE(movement_id, participant_user_id),
    UNIQUE(movement_id, participant_contact_id)
);

-- Indexes
CREATE INDEX idx_movement_participants_movement ON movement_participants(movement_id);
CREATE INDEX idx_movement_participants_user ON movement_participants(participant_user_id) WHERE participant_user_id IS NOT NULL;
CREATE INDEX idx_movement_participants_contact ON movement_participants(participant_contact_id) WHERE participant_contact_id IS NOT NULL;

-- Add constraint to ensure participants sum to 100%
-- This will be validated in application code, not DB constraint (too complex for SQL)
```

### Schema Design Decisions

**1. Payer/Counterparty/Participant as User OR Contact**
- Using nullable FK pairs (`payer_user_id`, `payer_contact_id`) with CHECK constraints
- Maintains referential integrity
- Avoids polymorphic associations
- Clear in queries which type is being referenced

**2. Category as VARCHAR (not ENUM or table)**
- Categories are hardcoded in backend for now (Phase 5)
- Will migrate to per-household categories table in Phase 6
- VARCHAR allows flexibility during transition

**3. Currency field**
- Defaults to 'COP' to match current behavior
- Allows future multi-currency support
- Matches Google Sheets column

**4. No Mes/Semana columns**
- These are computed from `movement_date`
- Can be calculated in queries or application code
- Reduces redundancy

**5. Payment method nullable**
- Required for HOUSEHOLD (always household member paying)
- Optional for SPLIT/DEBT_PAYMENT when payer is external contact
- Enforced in application logic, not DB constraint

---

## üèóÔ∏è Backend Implementation

### Module Structure

Following the pattern from `internal/income`:

```
backend/internal/movements/
‚îú‚îÄ‚îÄ types.go          # Movement, Participant types, enums, interfaces
‚îú‚îÄ‚îÄ repository.go     # PostgreSQL data access
‚îú‚îÄ‚îÄ service.go        # Business logic + dual-write to n8n
‚îî‚îÄ‚îÄ handlers.go       # HTTP handlers (CREATE, LIST, UPDATE, DELETE)
```

### Types (types.go)

```go
package movements

import (
    "context"
    "time"
)

// MovementType represents the type of movement
type MovementType string

const (
    TypeHousehold    MovementType = "HOUSEHOLD"
    TypeSplit        MovementType = "SPLIT"
    TypeDebtPayment  MovementType = "DEBT_PAYMENT"
)

// Movement represents a financial movement/expense
type Movement struct {
    ID          string       `json:"id"`
    HouseholdID string       `json:"household_id"`
    Type        MovementType `json:"type"`
    Description string       `json:"description"`
    Amount      float64      `json:"amount"`
    Category    *string      `json:"category,omitempty"`
    MovementDate time.Time   `json:"movement_date"`
    Currency    string       `json:"currency"`
    
    // Payer (exactly one)
    PayerUserID    *string `json:"payer_user_id,omitempty"`
    PayerContactID *string `json:"payer_contact_id,omitempty"`
    PayerName      string  `json:"payer_name"` // Populated from join
    
    // Counterparty (only for DEBT_PAYMENT)
    CounterpartyUserID    *string `json:"counterparty_user_id,omitempty"`
    CounterpartyContactID *string `json:"counterparty_contact_id,omitempty"`
    CounterpartyName      *string `json:"counterparty_name,omitempty"` // Populated from join
    
    // Payment method
    PaymentMethodID   *string `json:"payment_method_id,omitempty"`
    PaymentMethodName *string `json:"payment_method_name,omitempty"` // Populated from join
    
    // Participants (only for SPLIT)
    Participants []Participant `json:"participants,omitempty"`
    
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// Participant represents a participant in a shared expense
type Participant struct {
    ID                  string  `json:"id"`
    MovementID          string  `json:"movement_id"`
    ParticipantUserID   *string `json:"participant_user_id,omitempty"`
    ParticipantContactID *string `json:"participant_contact_id,omitempty"`
    ParticipantName     string  `json:"participant_name"` // Populated from join
    Percentage          float64 `json:"percentage"` // 0.0 to 1.0
    CreatedAt           time.Time `json:"created_at"`
}

// CreateMovementInput represents input for creating a movement
type CreateMovementInput struct {
    Type        MovementType `json:"type"`
    Description string       `json:"description"`
    Amount      float64      `json:"amount"`
    Category    *string      `json:"category,omitempty"`
    MovementDate time.Time   `json:"movement_date"`
    
    // Payer (exactly one required)
    PayerUserID    *string `json:"payer_user_id,omitempty"`
    PayerContactID *string `json:"payer_contact_id,omitempty"`
    
    // Counterparty (required only for DEBT_PAYMENT)
    CounterpartyUserID    *string `json:"counterparty_user_id,omitempty"`
    CounterpartyContactID *string `json:"counterparty_contact_id,omitempty"`
    
    // Payment method (required for HOUSEHOLD, conditional for others)
    PaymentMethodID *string `json:"payment_method_id,omitempty"`
    
    // Participants (required only for SPLIT)
    Participants []ParticipantInput `json:"participants,omitempty"`
}

// ParticipantInput represents input for a participant
type ParticipantInput struct {
    ParticipantUserID   *string `json:"participant_user_id,omitempty"`
    ParticipantContactID *string `json:"participant_contact_id,omitempty"`
    Percentage          float64 `json:"percentage"` // 0.0 to 1.0
}

// Repository interface
type Repository interface {
    Create(ctx context.Context, input *CreateMovementInput, householdID string) (*Movement, error)
    GetByID(ctx context.Context, id string) (*Movement, error)
    ListByHousehold(ctx context.Context, householdID string, filters *ListFilters) ([]*Movement, error)
    Update(ctx context.Context, id string, input *UpdateMovementInput) (*Movement, error)
    Delete(ctx context.Context, id string) error
}

// Service interface
type Service interface {
    Create(ctx context.Context, userID string, input *CreateMovementInput) (*Movement, error)
    GetByID(ctx context.Context, userID, id string) (*Movement, error)
    ListByHousehold(ctx context.Context, userID string, filters *ListFilters) ([]*Movement, error)
    Update(ctx context.Context, userID, id string, input *UpdateMovementInput) (*Movement, error)
    Delete(ctx context.Context, userID, id string) error
}
```

### Service Layer (service.go)

Key responsibilities:
1. **Validation**: Ensure input is valid for movement type
2. **Authorization**: Verify user has access to household
3. **Business Rules**: 
   - HOUSEHOLD: category + payment method required
   - SPLIT: participants required, percentages sum to 100%
   - DEBT_PAYMENT: counterparty required, category required if payer is household member
4. **Dual-write**: Save to PostgreSQL first, then forward to n8n
5. **Error handling**: If n8n fails, return 503 (like income does)

### n8n Client Integration

The `n8nclient.Client` already has the `Movement` struct and `RecordMovement` method. We need to:

1. **Convert from CreateMovementInput to n8nclient.Movement** in service layer
2. **Resolve IDs to names** for n8n compatibility:
   - `payer_user_id` ‚Üí look up user name
   - `payment_method_id` ‚Üí look up payment method name
   - etc.

---

## üé® Frontend Changes

### Current Flow (Phase 0)
```
Frontend ‚Üí n8n webhook (names as strings)
```

### New Flow (Phase 5)
```
Frontend ‚Üí Go backend API (IDs) ‚Üí PostgreSQL + n8n (dual-write)
```

### Changes Needed in `registrar-movimiento.js`

**1. Update form submission** (lines ~1070-1140)

Current:
```javascript
const payload = {
  fecha,
  tipo: 'gasto',
  sub_tipo: tipo,
  descripcion,
  categoria,
  valor,
  pagador,      // ‚Üê name string
  contraparte,  // ‚Üê name string
  metodo_pago,  // ‚Üê name string
  participantes: [...] // ‚Üê array with names
};

fetch(getMovementsApiUrl(), { // ‚Üê n8n webhook
  method: 'POST',
  body: JSON.stringify(payload)
});
```

New:
```javascript
const payload = {
  type: tipo, // HOUSEHOLD, SPLIT, DEBT_PAYMENT
  description: descripcion,
  amount: valor,
  category: categoria || null,
  movement_date: fecha,
  
  // Payer (send ID, not name)
  payer_user_id: usersMap[pagador]?.type === 'member' ? usersMap[pagador].id : null,
  payer_contact_id: usersMap[pagador]?.type === 'contact' ? usersMap[pagador].id : null,
  
  // Counterparty (for DEBT_PAYMENT)
  counterparty_user_id: tipo === 'DEBT_PAYMENT' && usersMap[contraparte]?.type === 'member' 
    ? usersMap[contraparte].id : null,
  counterparty_contact_id: tipo === 'DEBT_PAYMENT' && usersMap[contraparte]?.type === 'contact' 
    ? usersMap[contraparte].id : null,
  
  // Payment method (send ID, not name)
  payment_method_id: metodo || null,
  
  // Participants (for SPLIT - send IDs)
  participants: tipo === 'SPLIT' ? participants.map(p => ({
    participant_user_id: usersMap[p.name]?.type === 'member' ? usersMap[p.name].id : null,
    participant_contact_id: usersMap[p.name]?.type === 'contact' ? usersMap[p.name].id : null,
    percentage: Number(p.pct || 0) / 100
  })) : []
};

fetch(`${API_URL}/movements`, { // ‚Üê Go backend
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  credentials: 'include',
  body: JSON.stringify(payload)
});
```

**2. Update form config loading** (already done)
- The `/movement-form-config` endpoint already returns users/payment methods with IDs
- Just need to build `usersMap` for easy lookup by name

**3. Handle 503 errors gracefully** (like income does)
```javascript
if (res.status === 503) {
  setStatus('‚ö†Ô∏è Movimiento guardado en base de datos pero no sincronizado con Google Sheets. Por favor contacta al administrador.', 'warning');
  // Still reset form
}
```

---

## üìã Implementation Plan

### Week 1: Backend Foundation

**Day 1-2: Database Schema**
- [x] Review current n8n client and movement handler
- [ ] Create migration 016: `movements` table
- [ ] Create migration 017: `movement_participants` table
- [ ] Run migrations in dev environment
- [ ] Test with sample data

**Day 3-4: Backend Module**
- [ ] Create `internal/movements/types.go`
  - Movement, Participant structs
  - CreateMovementInput, UpdateMovementInput
  - Repository, Service interfaces
  - Validation methods
- [ ] Create `internal/movements/repository.go`
  - Create (movement + participants in transaction)
  - GetByID (with joins for names)
  - ListByHousehold (with filters: date range, type, member)
  - Update (handle participant changes)
  - Delete (cascade deletes participants)
- [ ] Create `internal/movements/service.go`
  - Business logic + authorization
  - Dual-write to n8n (like income service)
  - ID ‚Üí name resolution for n8n payload
  - Validation rules per movement type

**Day 5: HTTP Handlers**
- [ ] Update `internal/movements/handler.go`
  - Remove proxy-only logic
  - Add Create, List, GetByID, Update, Delete handlers
- [ ] Register routes in `httpserver/server.go`
  - POST /movements ‚Üí Create
  - GET /movements ‚Üí List (with query params for filters)
  - GET /movements/{id} ‚Üí GetByID
  - PATCH /movements/{id} ‚Üí Update
  - DELETE /movements/{id} ‚Üí Delete
- [ ] Update existing POST /movements proxy to use new service

### Week 2: Frontend Integration

**Day 1-2: Update Frontend**
- [ ] Update `registrar-movimiento.js`
  - Build `usersMap` from form config
  - Update payload structure (IDs instead of names)
  - Change API endpoint to `/movements`
  - Handle 503 errors (n8n failure)
- [ ] Test all 3 movement types
  - HOUSEHOLD (household expense)
  - SPLIT (split expense)
  - DEBT_PAYMENT (debt payment)

**Day 3: Testing**
- [ ] E2E tests for each movement type
- [ ] Test dual-write (PostgreSQL + Google Sheets)
- [ ] Test n8n failure scenarios
- [ ] Test participant percentage validation
- [ ] Test authorization (users can only access their household)

**Day 4: Home Dashboard Integration**
- [ ] Add movements list to home dashboard
- [ ] Filter by month (like income)
- [ ] Show totals by category
- [ ] Group by type (HOUSEHOLD, SPLIT, DEBT_PAYMENT)

### Week 3: Data Migration & Cleanup

**Day 1-2: Migration Script**
- [ ] Create script to export from Google Sheets
- [ ] Parse and validate data
- [ ] Map names to IDs (users, contacts, payment methods)
- [ ] Handle missing references gracefully
- [ ] Dry-run mode for validation

**Day 3: Run Migration**
- [ ] Backup Google Sheets
- [ ] Run migration script
- [ ] Validate data integrity
- [ ] Compare totals with Google Sheets

**Day 4: Documentation & Cleanup**
- [ ] Update API documentation
- [ ] Update user guide
- [ ] Update this document with actual implementation details
- [ ] Mark Phase 5 as complete

---

## ‚ö†Ô∏è Risk Mitigation

### Risk: Dual-write failure
**Mitigation:** 
- Save to PostgreSQL first (source of truth)
- If n8n fails, return 503 but data is saved
- User sees warning but form resets
- Admin can manually sync later

### Risk: Data inconsistency during migration
**Mitigation:**
- Keep n8n webhook active during migration
- New movements go to both systems
- Migration script only imports historical data
- Validate totals match after migration

### Risk: Breaking existing frontend
**Mitigation:**
- Keep `/movements` POST endpoint accepting both formats during transition
- Gradually update frontend
- Can run both formats in parallel for testing

### Risk: Category validation breaks workflow
**Mitigation:**
- Don't validate categories in Phase 5
- Accept any string (like current)
- Add validation in Phase 6 when categories table exists

---

## üéØ Success Criteria

- [ ] Movements table created with proper constraints
- [ ] All 3 movement types can be created via API
- [ ] Dual-write to n8n working (PostgreSQL + Google Sheets)
- [ ] Frontend updated to send IDs instead of names
- [ ] Participants percentages validated (sum to 100%)
- [ ] Authorization working (household isolation)
- [ ] n8n failures handled gracefully (503 response)
- [ ] Historical data migrated successfully
- [ ] Totals match between PostgreSQL and Google Sheets
- [ ] No regressions in existing functionality

---

## üìù Open Questions

1. **Payment method requirement for COMPARTIDO/PAGO_DEUDA**
   - Current: required if payer is household member
   - Should we enforce this in DB constraint or application logic?
   - **Decision:** Application logic (too complex for CHECK constraint)

2. **Soft delete vs hard delete**
   - Should deleted movements be soft-deleted (is_deleted flag)?
   - Or hard-deleted from database?
   - **Decision:** Hard delete for now, can add soft delete later if needed

3. **Historical data migration timing**
   - Migrate all at once or incrementally?
   - **Decision:** All at once during a maintenance window

4. **Categories table**
   - Implement now or wait for Phase 6?
   - **Decision:** Wait for Phase 6, use VARCHAR for now

---

**Last Updated:** 2026-01-06  
**Status:** üìã PLANNED  
**Next Action:** Create migrations 016 and 017
